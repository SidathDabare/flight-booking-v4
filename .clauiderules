# Flight Booking Application - Claude Code Rules

## CRITICAL REQUIREMENTS - READ FIRST

### üîí Production-Ready Code Standard
**ALL code generated MUST be production-ready and follow these mandatory checks:**

1. **Security Audit (MANDATORY)**
   - After writing ANY code, perform a comprehensive security review
   - Verify NO sensitive information is exposed in the frontend (API keys, secrets, credentials)
   - Check for common vulnerabilities: XSS, SQL injection, CSRF, insecure authentication
   - Ensure all user inputs are validated and sanitized
   - Verify proper authorization checks are in place
   - Confirm environment variables are used correctly (never hardcoded secrets)
   - Check that API routes have proper authentication/authorization
   - Validate that error messages don't leak sensitive information

2. **Token Budget Awareness (MANDATORY)**
   - BEFORE starting major implementations, estimate token usage
   - Check remaining token budget (visible in system warnings)
   - If implementation requires >30,000 tokens, confirm with user first
   - Break large tasks into smaller chunks if needed
   - Current session budget should always be monitored

3. **Code Quality Standards**
   - All code must be fully typed with TypeScript
   - Comprehensive error handling with try-catch blocks
   - Input validation using Zod schemas
   - Proper loading and error states in UI
   - Mobile-responsive and accessible
   - Dark mode compatible
   - Follows all patterns defined in this rules file

### üîê Security Checklist (Run After Every Code Generation)
```
‚úì No API keys, secrets, or credentials in client-side code
‚úì All environment variables properly accessed via process.env (server-side only)
‚úì User inputs validated with Zod schemas
‚úì SQL/NoSQL injection prevention (parameterized queries, Mongoose)
‚úì XSS prevention (React's built-in escaping + proper sanitization)
‚úì CSRF protection (NextAuth handles this)
‚úì Authentication checks on all protected routes
‚úì Authorization checks (role-based access control)
‚úì Secure password handling (bcrypt hashing)
‚úì Rate limiting considered for sensitive endpoints
‚úì Error messages don't expose system details
‚úì File uploads are validated and sanitized
‚úì Session tokens are httpOnly and secure
‚úì No sensitive data in console.log statements
‚úì Database queries don't expose unnecessary data
```

### üìä Token Management Protocol
- **Small changes** (<5,000 tokens): Proceed without warning
- **Medium changes** (5,000-15,000 tokens): Mention estimated usage
- **Large changes** (15,000-50,000 tokens): Get explicit confirmation
- **Major refactors** (>50,000 tokens): Break into phases, confirm each phase

---

## Project Overview
Next.js 15 flight booking platform with NextAuth authentication, MongoDB, Stripe payments, and Socket.IO real-time messaging. Uses TypeScript, Tailwind CSS with shadcn/ui components, and next-intl for internationalization.

## Technology Stack
- **Framework**: Next.js 15 (App Router)
- **Language**: TypeScript 5
- **Styling**: Tailwind CSS 3.4+ with custom Stripe-inspired design system
- **UI Library**: shadcn/ui (Radix UI primitives)
- **Authentication**: NextAuth.js v4 with MongoDB adapter
- **Database**: MongoDB with Mongoose
- **Payments**: Stripe
- **Real-time**: Socket.IO
- **Forms**: React Hook Form + Zod validation
- **State Management**: Zustand
- **Internationalization**: next-intl
- **Images**: next-cloudinary

## Code Style & Conventions

### General Rules
- Always use TypeScript with strict typing
- Prefer functional components with React hooks
- Use `"use client"` directive only when necessary (client components)
- Use async/await for asynchronous operations
- Always handle errors with try-catch blocks
- Use meaningful variable and function names

### File Naming
- Components: PascalCase (e.g., `FlightSearch.tsx`, `UserAvatar.tsx`)
- Utilities/Hooks: camelCase (e.g., `useScrollAnimation.ts`, `formatDate.ts`)
- API Routes: kebab-case (e.g., `create-booking.ts`)
- Pages: kebab-case (e.g., `ticket-details/page.tsx`)

### Component Structure
```typescript
"use client"; // Only if needed

import React from "react";
import { ComponentProps } from "@/types"; // Type imports first
import { Button } from "@/components/ui/button"; // UI components
import { cn } from "@/lib/utils"; // Utilities last

interface ComponentNameProps {
  // Props definition
}

const ComponentName = ({ prop1, prop2 }: ComponentNameProps) => {
  // Hooks at the top
  // State declarations
  // Event handlers
  // Effects

  return (
    <div className="...">
      {/* Component JSX */}
    </div>
  );
};

export default ComponentName;
```

### Import Order
1. React and Next.js imports
2. Third-party libraries
3. Type imports
4. UI components from `@/components/ui`
5. Custom components
6. Utils, hooks, and lib functions
7. Types and constants

### TypeScript Guidelines
- Always define interfaces for component props
- Use `type` for unions and `interface` for object shapes
- Avoid `any` - use `unknown` or proper typing
- Export types/interfaces when used across files
- Use optional chaining (`?.`) and nullish coalescing (`??`)

## Design System

### Colors
- Use CSS variables via Tailwind: `bg-primary`, `text-foreground`, etc.
- Custom Stripe-inspired colors available: `stripe-purple`, `stripe-blue-500`, etc.
- Gray scale: `gray-50` to `gray-950`
- Always support dark mode with appropriate color classes

### Typography
Use custom font size utilities:
- Headings: `text-h1` to `text-h6`
- Body: `text-body-lg`, `text-body`, `text-body-sm`
- Display: `text-display`
- Caption: `text-caption`

### Spacing
Use custom spacing scale:
- `xs`, `sm`, `md`, `lg`, `xl`, `2xl`, `3xl`, `4xl`, `5xl`, `6xl`

### Border Radius
- Prefer: `rounded-lg` (16px), `rounded-md` (12px), `rounded-xl` (24px)
- Use `rounded-2xl` (32px) for large cards

### Shadows
Use Stripe-inspired shadows:
- `shadow-stripe-sm`, `shadow-stripe-md`, `shadow-stripe-lg`, `shadow-stripe-xl`

### Button Animations
- Use `hover:-translate-y-0.5` for lift effect
- Add `will-change-transform` for performance
- Use `active:translate-y-0` for press effect

## Component Patterns

### Buttons
```typescript
import { Button } from "@/components/ui/button";

<Button variant="default" size="lg">
  Click Me
</Button>

// Variants: default, destructive, outline, secondary, ghost, link
// Sizes: default, sm, lg, icon
```

### Forms
```typescript
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";

const formSchema = z.object({
  email: z.string().email(),
});

const MyForm = () => {
  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: { email: "" },
  });

  const onSubmit = async (data: z.infer<typeof formSchema>) => {
    // Handle submission
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </form>
    </Form>
  );
};
```

### Cards
```typescript
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";

<Card className="shadow-stripe-md rounded-xl">
  <CardHeader>
    <CardTitle>Title</CardTitle>
    <CardDescription>Description</CardDescription>
  </CardHeader>
  <CardContent>
    {/* Content */}
  </CardContent>
</Card>
```

### Dialogs/Modals
```typescript
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";

<Dialog>
  <DialogTrigger asChild>
    <Button>Open Dialog</Button>
  </DialogTrigger>
  <DialogContent>
    <DialogHeader>
      <DialogTitle>Dialog Title</DialogTitle>
    </DialogHeader>
    {/* Dialog content */}
  </DialogContent>
</Dialog>
```

## API Routes

### Structure
```typescript
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import dbConnect from "@/lib/mongodb";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    await dbConnect();

    // Logic here

    return NextResponse.json({ data: result });
  } catch (error) {
    console.error("Error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
```

### Error Handling
Always return proper HTTP status codes:
- 200: Success
- 201: Created
- 400: Bad Request
- 401: Unauthorized
- 403: Forbidden
- 404: Not Found
- 500: Internal Server Error

## Authentication & Authorization

### Protected Routes
Use middleware for route protection based on user roles (admin, agent, client).

### Session Access
```typescript
// Client-side
import { useSession } from "next-auth/react";
const { data: session, status } = useSession();

// Server-side
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
const session = await getServerSession(authOptions);
```

### Role-Based Access
Check `session.user.role` and `session.user.isApproved` for authorization.

## Database (MongoDB + Mongoose)

### Model Definition
```typescript
import mongoose from "mongoose";

const Schema = new mongoose.Schema({
  field: { type: String, required: true },
  createdAt: { type: Date, default: Date.now },
});

export default mongoose.models.ModelName || mongoose.model("ModelName", Schema);
```

### Always use `dbConnect()` before database operations

## Internationalization (next-intl)

### Using Translations
```typescript
import { useTranslations } from "next-intl";

const Component = () => {
  const t = useTranslations("namespace");

  return <h1>{t("key")}</h1>;
};
```

## State Management

### React Context Pattern (For Component Tree State)
Use React Context for shared state across component trees that don't need persistence.

```typescript
import { createContext, useContext, useState, ReactNode } from "react";

interface ContextState {
  value: string;
  setValue: (value: string) => void;
}

const MyContext = createContext<ContextState | undefined>(undefined);

export const MyProvider = ({ children }: { children: ReactNode }) => {
  const [value, setValue] = useState<string>("");

  return (
    <MyContext.Provider value={{ value, setValue }}>
      {children}
    </MyContext.Provider>
  );
};

export const useMyContext = () => {
  const context = useContext(MyContext);
  if (!context) {
    throw new Error("useMyContext must be used within MyProvider");
  }
  return context;
};
```

**Real examples in codebase:**
- Socket.IO context: `lib/socket-context.tsx`
- Unread messages context: `lib/unread-messages-context.tsx`

---

### Zustand with Persistence (For Global State with TTL)
Use Zustand with persist middleware for global state that needs to survive page refreshes with expiration.

```typescript
import { create } from "zustand";
import { persist, devtools } from "zustand/middleware";

interface MyStore {
  data: DataType | null;
  timestamp: number | null;
  setData: (data: DataType | null) => void;
  clearExpired: () => boolean;
  getTimeRemaining: () => number | null;
}

const EXPIRATION_MS = 20 * 60 * 1000; // 20 minutes

const useMyStore = create<MyStore>()(
  persist(
    devtools(
      (set, get) => ({
        data: null,
        timestamp: null,

        setData: (data) => {
          set({
            data,
            timestamp: data ? Date.now() : null,
          });
        },

        clearExpired: () => {
          const { timestamp, data } = get();
          if (!timestamp || !data) return false;

          const elapsed = Date.now() - timestamp;
          if (elapsed > EXPIRATION_MS) {
            set({ data: null, timestamp: null });
            return true;
          }
          return false;
        },

        getTimeRemaining: () => {
          const { timestamp } = get();
          if (!timestamp) return null;
          const remaining = EXPIRATION_MS - (Date.now() - timestamp);
          return remaining > 0 ? remaining : 0;
        },
      }),
      { name: "My Store" }
    ),
    {
      name: "my-storage",
      partialize: (state) => ({
        data: state.data,
        timestamp: state.timestamp,
      }),
      storage: {
        getItem: (name) => {
          const str = localStorage.getItem(name);
          if (!str) return null;

          try {
            const { state } = JSON.parse(str);
            const { timestamp, data } = state;

            if (timestamp && data) {
              const elapsed = Date.now() - timestamp;
              if (elapsed > EXPIRATION_MS) {
                localStorage.removeItem(name);
                return null;
              }
            }
            return str;
          } catch {
            return null;
          }
        },
        setItem: (name, value) => localStorage.setItem(name, value),
        removeItem: (name) => localStorage.removeItem(name),
      },
    }
  )
);

// Auto-check expiration on load and periodically
if (typeof window !== "undefined") {
  setTimeout(() => useMyStore.getState().clearExpired(), 100);
  setInterval(() => useMyStore.getState().clearExpired(), 60 * 1000);
}

export default useMyStore;
```

**When to use:**
- Data needs to survive page refresh
- Data has a Time-To-Live (TTL)
- Global state shared across routes
- User selections that should persist temporarily

**Real examples in codebase:**
- Flight selection store: `lib/store/use-flight-store.ts` (20-minute TTL)
- Passenger details store: `lib/store/use-passenger-store.ts` (20-minute TTL, PII handling)

---

### Zustand with Persistence for PII Data (Special Considerations)

‚ö†Ô∏è **When persisting Personally Identifiable Information (PII), apply additional security measures:**

**PII includes:** Passport numbers, date of birth, email, phone numbers, full names

**Required Security Measures:**
1. **Short TTL:** Maximum 20 minutes (match business flow duration)
2. **User Warning:** Display banner informing users data is temporarily stored
3. **Manual Clear:** Provide "Clear Now" button for user control
4. **Auto-Clear:** Remove data after transaction completes
5. **Never Store Payment Data:** Credit cards, CVV, etc. (PCI DSS violation)

**Example Warning Banner:**
```typescript
{passengers.length > 0 && persistedAt && (
  <div className="border border-yellow-200 bg-yellow-50 p-4 rounded-lg">
    <div className="flex items-start gap-3">
      <AlertTriangle className="h-5 w-5 text-yellow-600" />
      <div className="flex-1">
        <p className="text-sm font-medium text-yellow-800">
          Sensitive Information Stored
        </p>
        <p className="text-xs text-yellow-700">
          Your passenger details are temporarily saved for convenience.
          They will be automatically cleared in 20 minutes or after booking completion.
        </p>
      </div>
      <Button onClick={clearPassengers}>Clear Now</Button>
    </div>
  </div>
)}
```

**GDPR Compliance Checklist:**
- ‚úÖ User consent: Warning banner (informed consent)
- ‚úÖ Data minimization: Only store necessary fields
- ‚úÖ Storage limitation: Auto-delete after 20 minutes
- ‚úÖ Right to erasure: "Clear Now" button

**Real example in codebase:**
- Passenger store: `lib/store/use-passenger-store.ts`
- Warning banner: `app/(root)/booking/page.tsx` (security banner section)

---

### Choosing Between Context and Zustand

| Use Case | Pattern | Why |
|----------|---------|-----|
| Component tree state | React Context | Simple, no persistence needed |
| Socket connections | React Context | Lifecycle tied to component tree |
| Form state | React Hook Form | Built-in validation |
| Global state without persistence | Zustand (no persist) | Simple global state |
| **Global state with persistence** | **Zustand + persist** | **Survives refresh, TTL support** |
| **Temporary user selections** | **Zustand + persist** | **Better UX, recoverable state** |

## Performance Optimization

- Use React.memo() for expensive components
- Implement proper loading states with Skeleton components
- Use next/image for all images
- Lazy load heavy components with dynamic imports
- Use server components by default, only add "use client" when necessary

## Accessibility

- Always include proper ARIA labels
- Ensure keyboard navigation works
- Use semantic HTML elements
- Maintain proper color contrast ratios
- Add alt text to all images

## Input Validation

**All user inputs MUST be validated:**

- **Client-side:** Use Zod schemas with React Hook Form
- **Server-side:** Always re-validate with Zod in API routes (never trust client)
- **Sanitization:** Clean user inputs to prevent XSS/injection
- **TypeScript:** Strict mode enabled for compile-time safety

```typescript
// Example: Zod schema for validation
import { z } from "zod";

const userSchema = z.object({
  email: z.string().email("Invalid email"),
  name: z.string().min(2).max(100),
  age: z.number().int().positive().optional(),
});

// Server-side validation
const result = userSchema.safeParse(data);
if (!result.success) {
  return NextResponse.json({ error: "Invalid input" }, { status: 400 });
}
```

## Testing (FUTURE ENHANCEMENT)
**Status:** ‚ö†Ô∏è Not yet implemented

Consider adding testing frameworks:
- **Unit/Integration:** Jest + React Testing Library
- **E2E Testing:** Playwright or Cypress
- **API Testing:** Supertest or Vitest

## Styling Guidelines

### Layout
```typescript
// Container pattern
<div className="container mx-auto px-4 py-8 max-w-7xl">
  {/* Content */}
</div>

// Flex layouts
<div className="flex items-center justify-between gap-4">
  {/* Items */}
</div>

// Grid layouts
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
  {/* Cards */}
</div>
```

### Responsive Design
- Mobile-first approach
- Breakpoints: `sm:`, `md:`, `lg:`, `xl:`, `2xl:`, and custom `xs:`
- Always test on multiple screen sizes

### Dark Mode
```typescript
// Use Tailwind dark mode classes
<div className="bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
  {/* Content adapts to theme */}
</div>
```

## Common Utilities

### cn() for Class Names
```typescript
import { cn } from "@/lib/utils";

<div className={cn("base-class", conditional && "conditional-class", className)} />
```

### Date Formatting
```typescript
import { format } from "date-fns";

const formatted = format(new Date(), "PPP");
```

## Error Handling UI

- Use toast notifications for user feedback
- Display meaningful error messages
- Implement error boundaries for crash recovery
- Log errors appropriately (console.error)

## Security Best Practices

### Environment Variables & Secrets
- **NEVER** hardcode API keys, secrets, or credentials
- Use `.env.local` for local development (gitignored)
- Access via `process.env.VARIABLE_NAME` in server-side code ONLY
- Never expose environment variables to client components
- Validate all required env vars at build time

### Input Validation & Sanitization
```typescript
// Always validate with Zod
import { z } from "zod";

const schema = z.object({
  email: z.string().email(),
  name: z.string().min(2).max(100),
  age: z.number().int().positive(),
});

// In API routes
const result = schema.safeParse(data);
if (!result.success) {
  return NextResponse.json({ error: "Invalid input" }, { status: 400 });
}
```

### SQL/NoSQL Injection Prevention
- Use Mongoose schemas with proper types
- Never concatenate user input into queries
- Use parameterized queries
- Validate ObjectIds before queries

### XSS Prevention
- React automatically escapes JSX
- Sanitize HTML if using `dangerouslySetInnerHTML` (avoid if possible)
- Validate and sanitize all user inputs
- Use Content Security Policy headers

### Authentication & Authorization
```typescript
// Always check authentication
const session = await getServerSession(authOptions);
if (!session) {
  return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
}

// Always check authorization
if (session.user.role !== "admin") {
  return NextResponse.json({ error: "Forbidden" }, { status: 403 });
}

// For agents, check approval status
if (session.user.role === "agent" && !session.user.isApproved) {
  return NextResponse.json({ error: "Pending approval" }, { status: 403 });
}
```

### Password Security
```typescript
import bcrypt from "bcryptjs";

// Hashing (registration)
const hashedPassword = await bcrypt.hash(password, 12);

// Verification (login)
const isValid = await bcrypt.compare(password, user.hashedPassword);
```

### File Upload Security
```typescript
// Validate file types
const allowedTypes = ["image/jpeg", "image/png", "image/webp"];
if (!allowedTypes.includes(file.type)) {
  throw new Error("Invalid file type");
}

// Validate file size
const maxSize = 5 * 1024 * 1024; // 5MB
if (file.size > maxSize) {
  throw new Error("File too large");
}

// Use secure upload service (Cloudinary)
// Never store files directly in public directory without validation
```

### Rate Limiting (FUTURE ENHANCEMENT)
**Status:** ‚ö†Ô∏è Not yet implemented

For production deployments, consider implementing rate limiting for:
- Login endpoints (`/api/auth/signin`)
- Registration endpoints (`/api/auth/register`)
- Password reset endpoints
- High-frequency API routes

**Recommended approaches:**
```typescript
// Option 1: Upstash Rate Limit (Serverless-friendly)
// npm install @upstash/ratelimit @upstash/redis

// Option 2: Custom middleware with Redis
// Implement request counting per IP/user

// Option 3: Vercel Edge Config
// Use Vercel's built-in rate limiting for edge functions
```

### Error Handling Security
```typescript
// DON'T expose internal details
// ‚ùå BAD
return NextResponse.json({ error: error.message }, { status: 500 });

// ‚úÖ GOOD
console.error("Database error:", error); // Log for debugging
return NextResponse.json({ error: "Internal server error" }, { status: 500 });
```

### Session Security
- NextAuth handles secure session tokens
- Tokens are httpOnly cookies (protected from XSS)
- Use secure: true in production
- Set appropriate maxAge for sessions

### HTTPS & Production Security
- Always use HTTPS in production
- Set secure headers (HSTS, CSP, X-Frame-Options)
- Configure proper CORS policies
- Keep dependencies updated

## File Organization

```
app/
  (root)/          # Main app routes
  auth/            # Authentication pages
  admin/           # Admin dashboard
  agent/           # Agent dashboard
  client/          # Client dashboard
  api/             # API routes
components/
  ui/              # shadcn/ui components
  admin/           # Admin-specific components
  agent/           # Agent-specific components
  custom ui/       # Custom reusable components
  client/shared/   # Shared client UI patterns
lib/               # Utility functions and configs
hooks/             # Custom React hooks
types/             # TypeScript type definitions
public/            # Static assets
.claude/
  docs/            # All Claude Code-generated documentation
    guides/        # Setup and how-to guides
    architecture/  # System architecture and feature docs
    history/       # Historical fixes and improvements
```

### Documentation Organization (MANDATORY)

**ALL documentation MUST go in `.claude/docs/` folder:**

1. **Creating New Documentation**
   - Implementation guides ‚Üí `.claude/docs/architecture/`
   - Setup/how-to guides ‚Üí `.claude/docs/guides/`
   - Fix/improvement summaries ‚Üí `.claude/docs/history/`

2. **Root Directory Rules**
   - ‚úÖ Keep: `README.md` (project readme)
   - ‚úÖ Keep: `audit-report.md` (current audit state)
   - ‚ùå NO other .md files in root
   - Component READMEs stay with components (e.g., `app/(root)/about/README.md`)

3. **Documentation Standards**
   - Use clear markdown formatting
   - Include table of contents for long docs
   - Add date and status to implementation docs
   - Link to related code files with relative paths
   - Keep docs updated as features evolve

## Performance Requirements

### Image Optimization (MANDATORY)
- **Always use `next/image`** for all images
- Set proper `width` and `height` to prevent layout shift
- Use `priority` prop for above-the-fold images
- Use appropriate `quality` settings (default 75 is good)

### Server Components (DEFAULT)
- Use Server Components by default for better performance
- Only add `"use client"` when necessary:
  - Component uses React hooks (useState, useEffect, etc.)
  - Component needs browser APIs (window, document)
  - Component handles user interactions
  - Component uses client-only libraries

### API Routes (MANDATORY)
- Implement comprehensive error handling with try-catch
- Return appropriate HTTP status codes (200, 400, 401, 403, 404, 500)
- Never expose internal error details to clients
- Log errors server-side for debugging

### Database Optimization
- Use indexes for frequently queried fields
- Implement pagination for large result sets
- Use `.select()` to fetch only needed fields
- Avoid N+1 queries (use `.populate()` wisely)
- Use `.lean()` for read-only operations

### UI State Management
- Implement loading states with Skeleton components
- Handle error states gracefully with error boundaries
- Provide user feedback for all actions (toasts, notifications)
- Show optimistic UI updates where appropriate

## Commit Message Style

Follow semantic commit format:
- `feat:` New feature
- `fix:` Bug fix
- `refactor:` Code refactoring
- `style:` UI/style changes
- `docs:` Documentation
- `chore:` Maintenance tasks

## Final Reminders

1. **Consistency is key** - Follow existing patterns in the codebase
2. **Mobile-first** - Always design for mobile, then enhance for desktop
3. **Accessibility** - Make it usable for everyone
4. **Performance** - Keep it fast
5. **Type safety** - Use TypeScript properly
6. **User experience** - Smooth animations, clear feedback, intuitive UI
7. **Dark mode** - Always support both themes
8. **Internationalization** - Use next-intl for all user-facing text
