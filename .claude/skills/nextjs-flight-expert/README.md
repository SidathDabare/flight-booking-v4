# Next.js Flight Booking Expert Skill

A specialized Claude Code skill for developing and maintaining the flight booking application with a focus on secure coding practices and DevSecOps principles.

## Overview

This skill provides expert-level assistance for:
- **Frontend Development** - React 19, Next.js 15 App Router, TypeScript, Tailwind CSS
- **Backend Development** - API Routes, Server Actions, MongoDB, NextAuth
- **Real-time Features** - Socket.IO integration and WebSocket management
- **Payment Integration** - Stripe checkout and webhook handling
- **Security Implementation** - OWASP Top 10 prevention, input validation, authentication
- **Code Quality** - TypeScript best practices, error handling, performance optimization

## How to Use

### Option 1: Via Skill Command (if configured)
```bash
/skill nextjs-flight-expert
```

### Option 2: Manual Activation
Simply reference the skill in your conversation:
```
"Using the nextjs-flight-expert skill, please implement a new API route for..."
```

### Option 3: Direct File Reference
The skill is automatically available when working in this codebase.

## What This Skill Knows

### Technology Stack
- ✅ Next.js 15.1.4 with App Router
- ✅ React 19.1.1 with Server Components
- ✅ TypeScript 5 with strict mode
- ✅ MongoDB + Mongoose 8.12
- ✅ NextAuth 4.24 (JWT strategy)
- ✅ Socket.IO 4.8 for real-time messaging
- ✅ Stripe 17.7 for payments
- ✅ Amadeus SDK for flight booking
- ✅ Cloudinary for file storage
- ✅ Zustand 4.5.2 for state management

### Application Architecture
- Complete route structure and organization
- Database models and relationships
- Authentication and authorization flows
- Payment processing workflows
- Real-time messaging implementation
- Multi-role system (client/agent/admin)

### Security Best Practices
- API route protection patterns
- Input validation with Zod
- NoSQL injection prevention
- File upload security
- Error handling without information leakage
- CSRF protection strategies
- Rate limiting implementation
- Security header configuration

### Code Patterns
- Server Actions for mutations
- API Routes with role-based access
- Zustand stores with persistence
- React Hook Form + Zod validation
- Socket.IO event handling
- Stripe webhook processing

## Common Use Cases

### 1. Adding a New Protected API Route
```
"Create a new API route at /api/bookings/[id]/cancel that allows users to cancel their bookings"
```

The skill will:
- Add proper session validation
- Implement role-based authorization
- Validate input with Zod
- Add error handling
- Include Socket.IO events if needed

### 2. Implementing a New Form
```
"Create a profile update form with validation for name, email, and phone number"
```

The skill will:
- Define Zod schema
- Create form component with React Hook Form
- Use Shadcn/ui components
- Add client and server validation
- Handle success/error states

### 3. Adding Real-time Features
```
"Add real-time notification when an admin approves an agent account"
```

The skill will:
- Define Socket.IO events
- Implement room-based access control
- Add client-side listeners
- Emit events from API routes

### 4. Security Fixes
```
"Fix the NoSQL injection vulnerability in the messages API"
```

The skill will:
- Identify the vulnerability
- Implement proper validation
- Add security tests
- Follow OWASP guidelines

### 5. Performance Optimization
```
"Optimize the database queries in the orders endpoint"
```

The skill will:
- Add proper indexes
- Use .lean() for read queries
- Implement field selection
- Add query optimization

## Security Focus

This skill emphasizes **DevSecOps** principles and will always:

1. **Validate All Inputs** - Zod schemas for every user input
2. **Prevent Injection** - NoSQL injection prevention in queries
3. **Authenticate Requests** - Session validation on protected routes
4. **Authorize Actions** - Role-based and ownership checks
5. **Sanitize Files** - File upload validation and sanitization
6. **Handle Errors Safely** - No information leakage in errors
7. **Use TypeScript Strictly** - No `any` types
8. **Follow OWASP Top 10** - Address all major security risks

## Code Quality Standards

All code generated by this skill follows:

- **Consistency** - Matches existing codebase patterns
- **Type Safety** - Full TypeScript type coverage
- **Error Handling** - Comprehensive try-catch blocks
- **Documentation** - JSDoc comments for complex logic
- **Performance** - Optimized queries and state management
- **Accessibility** - ARIA-compliant components
- **Mobile First** - Responsive design with Tailwind
- **Testing** - Security and functionality checklists

## Files Structure

```
.claude/skills/nextjs-flight-expert/
├── skill.md         # Main skill definition
├── README.md        # This file
└── examples/        # Code examples (optional)
```

## Reference Documentation

For comprehensive information, see:
- [skill.md](skill.md) - Complete skill definition
- [../../docs/SECURITY-AUDIT-REPORT.md](../../docs/SECURITY-AUDIT-REPORT.md) - Security audit and recommendations

## Examples

### Example 1: Creating a Secure API Endpoint
```typescript
// Request: "Create an API endpoint to delete a user order"

// app/api/orders/[orderId]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { connectToDatabase } from "@/lib/db/mongoose";
import Order from "@/lib/db/models/Order";
import { z } from "zod";

const paramsSchema = z.object({
  orderId: z.string().regex(/^[0-9a-fA-F]{24}$/, "Invalid order ID"),
});

export async function DELETE(
  req: NextRequest,
  { params }: { params: { orderId: string } }
) {
  try {
    // Validate session
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Validate params
    const { orderId } = paramsSchema.parse(params);

    await connectToDatabase();

    // Find order
    const order = await Order.findById(orderId);
    if (!order) {
      return NextResponse.json({ error: "Order not found" }, { status: 404 });
    }

    // Check ownership or admin
    if (
      order.metadata.userId !== session.user.id &&
      session.user.role !== "admin"
    ) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // Delete order
    await Order.findByIdAndDelete(orderId);

    // Emit Socket.IO event
    const io = (global as any).io;
    if (io) {
      io.to(`user:${session.user.id}`).emit("order:deleted", { orderId });
    }

    return NextResponse.json({
      success: true,
      message: "Order deleted successfully",
    });
  } catch (error) {
    console.error("Order deletion error:", error);
    return NextResponse.json(
      {
        error: "Internal server error",
        ...(process.env.NODE_ENV === "development" && {
          details: error instanceof Error ? error.message : "Unknown error",
        }),
      },
      { status: 500 }
    );
  }
}
```

### Example 2: Form with Validation
```typescript
// Request: "Create a contact form with subject and message fields"

"use client";

import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Button } from "@/components/ui/button";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { useState } from "react";

const formSchema = z.object({
  subject: z.string().min(5, "Subject must be at least 5 characters").max(200),
  message: z.string().min(10, "Message must be at least 10 characters").max(5000),
});

type FormData = z.infer<typeof formSchema>;

export function ContactForm() {
  const [isLoading, setIsLoading] = useState(false);

  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      subject: "",
      message: "",
    },
  });

  const onSubmit = async (data: FormData) => {
    try {
      setIsLoading(true);

      const response = await fetch("/api/messages", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        throw new Error("Failed to send message");
      }

      form.reset();
      // Show success toast
    } catch (error) {
      // Show error toast
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="subject"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Subject</FormLabel>
              <FormControl>
                <Input placeholder="Enter subject" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="message"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Message</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Enter your message"
                  rows={5}
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button type="submit" disabled={isLoading}>
          {isLoading ? "Sending..." : "Send Message"}
        </Button>
      </form>
    </Form>
  );
}
```

## Support

For questions or issues:
1. Check the [Security Audit Report](../../docs/SECURITY-AUDIT-REPORT.md) for security guidelines
2. Review [skill.md](skill.md) for comprehensive patterns and examples
3. Ask Claude Code with specific context about your task

---

**Last Updated:** 2025-11-14
**Version:** 1.0.0
**Maintainer:** Claude Code AI
